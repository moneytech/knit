#define KNIT_OBJ_HEAD \
    int ktype
struct knit_str {
    KNIT_OBJ_HEAD;
    char *str; //null terminated
    int len;
    int cap; //negative values mean memory is not owned by us (const char * passed to us)
};

struct knit_obj; //fwd

struct knit_list {
    KNIT_OBJ_HEAD;
    struct knit_obj **items;
    int len;
    int cap;
};
struct knit_int {
    KNIT_OBJ_HEAD;
    int value;
};

struct knit_obj {
    union knit_obj_u {
        int ktype;
        struct knit_list list;
        struct knit_str str;
    } u;
};
#include "knit_objp_darr.h" //autogenerated darr.h and prefixed by knit_objp_
enum KNIT_RV {
    KNIT_OK = 0,
    KNIT_NOMEM,
    KNIT_SYNTAX_ERR,
    KNIT_RUNTIME_ERR,
    KNIT_NOT_FOUND_ERR,
};
enum KNIT_TYPE {
    KNIT_NULL = 0xd6,
    KNIT_STR,
    KNIT_LIST,
    KNIT_INT,
};
enum KNIT_OPT {
    KNIT_POLICY_EXIT = 1, //default
    KNIT_POLICY_CONTINUE = 2,
};
enum KNIT_CONF {
    KNIT_MAX_ARGS = 6,
};

#include "hasht/third_party/strhash/superfasthash.h"

/*hashtable defs*/
    typedef struct knit_str    vars_hasht_key_type;   //internal notes: there is no indirection, init/deinit must be used
    typedef struct knit_obj  * vars_hasht_value_type; //                there is indirection,    new/destroy must be used
    int vars_hasht_key_eq_cmp(vars_hasht_key_type *key_1, vars_hasht_key_type *key_2) {
        struct knit_str *str1 = key_1;
        struct knit_str *str2 = key_2;
        if (str1->len != str2->len)
            return 1;
        return memcmp(str1->str, str2->str, str1->len); //0 if eq
    }
    size_t vars_hasht_hash(vars_hasht_key_type *key) {
        struct knit_str *str = key;
        return SuperFastHash(str->str, str->len);
    }

    typedef void * mem_hasht_key_type; 
    typedef unsigned char mem_hasht_value_type; //we don't really need a value, it is a set
    int mem_hasht_key_eq_cmp(mem_hasht_key_type *key_1, mem_hasht_key_type *key_2) {
        //we are comparing two void pointers
        if (*key_1 == *key_2)
            return 0; 
        return 1;
    }
    size_t mem_hasht_hash(mem_hasht_key_type *key) {
        return (uintptr_t) *key; //casting a void ptr to an integer
    }
/*end of hashtable defs*/

#include "vars_hasht.h" //autogenerated hasht.h and prefixed by vars_
#include "mem_hasht.h"  //autogenerated hasht.h and prefixed by mem_

struct knit_frame {
    struct knit_block *block;
    int bsp; //base stack pointer, (where locals indice are based on) this refers to the global values stack
    int ip;
};
#include "knit_frame_darr.h"
struct knit_stack {
    struct knit_frame_darr frames; //contains information about function calls and IPs
    struct knit_objp_darr vals;    //contains the objects (ints, strs, lists ...) pushed on stack
};

struct knit_exec_state {
    struct knit_stack stack;
};

struct knit_tok {
    int toktype;
    int lineno;
    int colno;
    int offset;
    int len;
    union {
        int integer;
    } data;
};
#include "tok_darr.h"  //autogenerated darr.h and prefixed by tok_


struct knit {
    struct vars_hasht vars_ht;
    struct mem_hasht mem_ht;

    struct knit_exec_state ex;

    char *err_msg;
    unsigned char is_err_msg_owned;
    int err;
    int err_policy;
};

enum KATOK {
    KAT_EOF,
    KAT_BOF, //begining of file
    KAT_STRLITERAL,
    KAT_INTLITERAL,
    KAT_VAR,
    KAT_DOT,
    KAT_EQUALS,
    KAT_OPAREN,
    KAT_CPAREN,
    KAT_OBRACKET,
    KAT_CBRACKET,
    KAT_COMMA,
    KAT_COLON,
    KAT_SEMICOLON,
    KAT_ADD,
    KAT_SUB,
    KAT_MUL,
    KAT_DIV,
    KAT_MOD,

    //not tokens
    KAT_ASSOC_LEFT,
    KAT_ASSOC_RIGHT,
};
enum KAEXPR {
    KAX_CALL,
    KAX_LITERAL_STR,
    KAX_LITERAL_INT,
    KAX_LITERAL_LIST,
    KAX_LIST_INDEX,
    KAX_LIST_SLICE,
    KAX_VAR_REF,
    KAX_OBJ_DOT,
    KAX_BIN_OP,
    KAX_UN_OP,
};
struct knit_expr {
    int exptype;
    union {

        struct knit_str *str;

        struct knit_list *list;

        int integer;

        struct knit_expr *exp;

        struct { 
            struct knit_expr *exp;
            struct knit_expr *beg;
            struct knit_expr *end;
        } slice;

        struct { 
            int op; //an INSN (KADD, KSUB...)
            struct knit_expr *lhs;
            struct knit_expr *rhs;
        } bin;
        struct { 
            int op; //an INSN (KNEG, etc..)
            struct knit_expr *operand;
        } un;

        struct knit_dot { 
            struct knit_str *str;
            struct knit_dot *next;
        };
        struct knit_prefix { 
            struct knit_expr *start;
            struct knit_dot *rest;
        } prefix;

        // foo  . bar   .baz    
        //              _knit_dot_
        //     _knit_dot__________
        //_prefix______________
        //
        struct knit_call *call;

        /*
        KAX_CALL: call
        KAX_LITERAL_STR: str
        KAX_LITERAL_INT: integer
        KAX_LITERAL_LIST: list
        KAX_VAR_REF: str
        KAX_LIST_INDEX: exp
        KAX_LIST_SLICE: slice
        KAX_OBJ_DOT: prefix
        KAX_BIN_OP: bin
        KAX_UN_OP: un
        */

    } u;
};
struct knit_func_args {
    struct knit_expr args[KNIT_MAX_ARGS];
    int nargs;
};
typedef struct knit_obj * ( *knit_func_type )(struct knit *, struct knit_func_args *);
struct knit_func {
    knit_func_type fptr;
};
struct knit_call {
    struct knit_expr *called;
    struct knit_func_args args;
};
//order tied to knit_insninfo
enum KNIT_INSN {
    /*
        s: stack
        t: current stack size (s[t-1] is top of stack)
     */
    KPUSH = 1, /*inputs: (index,)                       op: s[t] = s[index]; t++;*/
    KPOP,      /*inputs: (count,)                       op: t -= count;*/
    KLOAD,     /*inputs: (index,)                       op: s[t] = current_block_constants[index]; t++;*/
    KCALL,     /*inputs: (func_index,      nargs)       op: s[func_index](args...)*/
    KINDX,     /*inputs: (container_index, expr_index)  op: s[t] = (s[container_index])[s[expr_index]]; t++*/

    KADD,  /*s[t-2] = s[t-2] + s[t-1]; pop 1;*/
    KSUB,  /*s[t-2] = s[t-2] - s[t-1]; pop 1;*/
    KMUL,  /*s[t-2] = s[t-2] * s[t-1]; pop 1;*/
    KDIV,  /*s[t-2] = s[t-2] / s[t-1]; pop 1;*/
    KMOD,  /*s[t-2] = s[t-2] % s[t-1]; pop 1;*/
};
#define KINSN_FIRST KPUSH
#define KINSN_LAST  KMOD
#define KINSN_TVALID(type)  ((type) >= KINSN_FIRST && (type) <= KINSN_LAST)

//Order is tied to enum
static struct knit_insninfo {
    int insn_type;
    const char *rep;
    int n_op; //number of operands (used for dumping)
} knit_insninfo[] = {
    {0, NULL, 0},
    {KPUSH, "KPUSH", 1},
    {KPOP, "KPOP",   1},
    {KLOAD, "KLOAD", 1},
    {KCALL, "KCALL", 2},
    {KINDX, "KINDX", 2},
    {KADD, "KADD",   0},
    {KSUB, "KSUB",   0},
    {KMUL, "KMUL",   0},
    {KDIV, "KDIV",   0},
    {KMOD, "KMOD",   0},
    {0, NULL, 0},
};
struct knit_insn {
    int insn_type;
    int op1;
    int op2;
};
#include "insns_darr.h"
struct knit_block { 
    struct insns_darr insns;
    struct knit_objp_darr constants;
};
struct knit_lex {
    struct knit_str *filename;
    struct knit_str *input;
    int lineno;
    int colno;
    int offset;
    int tokno; //refers to an index in .tokens

    struct tok_darr tokens;
};
struct knit_prs {
    struct knit_lex lex; //fwd
    struct knit_expr expr;
    struct knit_block block;
};
